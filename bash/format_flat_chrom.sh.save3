#!/bin/bash

echo "in format_flat_chrom.sh:"

set -x

# non great lakes people will need to modify
#module load Bioinformatics
#module load bcftools

# Usage:
# bash format_flat_chrom.sh file chrom af_thresh snp_name pos_name chrom_name \
#   A1_name A2_name beta_hat_name se_name p_value_name af_name sample_size_name effect_is_or output.txt
# bash format_flat_chrom.sh data.tsv.gz 1 0.05 SNP POS CHR A1 A2 BETA SE PVALUE AF SS FALSE output.txt

echo " - loaded modules"

set -euo pipefail
trap 'echo "script failed with exit code $? at line $LINENO" >&2' ERR

echo " - set pipefail"

ref_bim="$1"
file="$2"
chrom="$3"
af_thresh="$4"
snp_name="$5"
pos_name="$6"
chrom_name="$7"
A1_name="$8"
A2_name="$9"
beta_hat_name="${10}"
se_name="${11}"
p_value_name="${12}"
af_name="${13}"
sample_size_name="${14}"
effect_is_or="${15}"   # "TRUE" or "FALSE"
output="${16}"

echo " - read function inputs"

# step 0: read ref input
# I need to generalize this.  there is some column hardcoding in here
# what can I do about allele freq??

# above we assumed first column was chromosome.  add a catcher?
# above we assumed all positive strand in ref.  add a catcher?
# above we assumed 6th (last) column was ref, 5th column was alt allele. https://www.cog-genomics.org/plink/2.0/formats  add a catcher?

# first, create output file:
# Get parent directory name
parentdir=$(basename "$(dirname "$file")")        # C100001554

# Get base file name without extensions
fname=$(basename "$file")                         # C100001554_regenie_rsid.tsv.gz
fname_noext="${fname%.tsv.gz}"                   # C100001554_regenie_rsid

# Compose new output file name
outfile="${fname_noext}_chrom${chrom}_harmon_snps.tsv"

awk '
BEGIN {
    # Load filtered reference from ARGV[1]
    while ((getline < ARGV[1]) > 0) {
        ref_alt[$1] = $2    # $1 = rsID, $2 = ALT, $3 = REF from processed BIM
        ref_ref[$1] = $3
    }
    ARGV[1] = ""           # So awk does not process this file as main input
}
# OR for actual harmonization, continue script here processing main file (ARGV[2])
#FNR == 1 { print $0; next }  # example: print header, or your harmonization logic
FNR==1 {
    split($0, hdr, "\t")
    print hdr[1] "\t" hdr[2] "\t" hdr[5] "\t" hdr[6] "\t" hdr[11] "\t" hdr[7] "\tharmon_ref_allele\tharmon_alt_allele\tharmon_beta\tharmon_alt_freq\tharmon_is_change"
    next
}

{
    snp = $1           # rsid
    gwas_ref_al = $5       # ALLELE0 (non-effect)
    gwas_alt_al = $6       # ALLELE1 (effect)
    beta = $11         # BETA

    # Check for reference availability
    if (!(snp in ref_alt)) next; # skip if not in reference

    ref_ref_al = ref_ref[snp]
    ref_alt_al = ref_alt[snp]

    # Check for ambiguous SNP (A/T or C/G), skip if ambiguous
    ambig_snp = (gwas_ref_al == "A" && gwas_alt_al == "T") || (gwas_ref_al == "T" && gwas_alt_al == "A") \
        || (gwas_ref_al == "C" && gwas_alt_al == "G") || (gwas_ref_al == "G" && gwas_alt_al == "C");
    if (ambig_snp) next;

    # Strandedness: alleles should always match reference since reference is on forward strand
    harmon_REF = ref_ref_al;
    harmon_ALT = ref_alt_al;

    # Try all possible allele orientations
    # Case 1: Exact match
    if (gwas_alt_al == ref_alt_al && gwas_ref_al == ref_ref_al) {
        flip = 0;
        # Output as is
        harmon_change = 0;
    }
    # Case 2: Flipped effect/non-effect
    else if (gwas_alt_al == ref_ref_al && gwas_alt_al == ref_alt_al) {
        flip = 1;
        # Output: harmonized alleles as reference
        harmon_change = 1;
    }
    # Case 3: complement alleles
    else if (dna_complement(gwas_alt_al) == ref_alt_al && dna_complement(gwas_ref_al) == ref_ref_al) {
        flip = 0;
        # Output harmonized alleles as reference, but input alleles are complement
        harmon_change = 1;
    }
    else if (dna_complement(gwas_alt_al) == ref_ref_al && dna_complement(gwas_ref_al) == ref_alt_al) {
        flip = 1;
        # Output harmonized alleles as reference, but swapped
        harmon_change = 1;
    }
    else {
        # Could not harmonize alleles, skip.
        next;
    }

    # Flip effect size if effect allele is reference (as opposed to alternate)
    if (flip) {
        harmon_beta = -$11;
        harmon_alt_freq = 1 - $7;
    } else {
        harmon_beta = $11;
        harmon_alt_freq = $7;
    }
    # Special handling: For complemented alleles, swap input alleles if needed to match reference, also output alleles as ref/alt
    # Output harmonized columns
    #print $0 "\t" harmon_REF "\t" harmon_ALT;
    # CHANGE HARMON ALLELE FREQ
    print $1 "\t" $2 "\t" $5 "\t" $6 "\t" $11 "\t" $7 "\t" harmon_REF "\t" harmon_ALT "\t" harmon_beta "\t" harmon_alt_freq "\t" harmon_change;
}
function dna_complement(base) {
    if (base == "A") return "T";
    if (base == "T") return "A";
    if (base == "C") return "G";
    if (base == "G") return "C";
    return base;
}
' <(awk -v c="$chrom" '$1 == c {print $2 "\t" $5 "\t" $6}' "$ref_bim") <(gzip -cd "$file") | \
{ read -r header; echo "$header"; sort -t $'\t' -k1,1; } > "$outfile"

# output is of the format:  C100001554_regenie_rsid_chrom1_harmon_snps.tsv
# need to read this back in and use the harmonized parts instead of the regular ones
# so harmonized ref allele, alt allele, effect size, alt allele freq

# Step 1: Parse header and find column numbers by name
# Before extracting, confirm file exists and is readable
if [[ ! -r "$file" ]]; then
    echo "Error: File '$file' does not exist or is not readable." >&2
    exit 1
fi

# Extract first line ("header") from file, avoiding SIGPIPE issues
if [[ "$file" == *.gz ]]; then
    header=$(awk 'NR==1 {print; exit}' <(gzip -cd "$file"))
else
    header=$(awk 'NR==1 {print; exit}' "$file")
fi

# Confirm header was extracted
if [[ -z "$header" ]]; then
    echo "Error: Header is empty or could not be read from '$file'." >&2
    exit 1
fi

echo " - read gwas file header"

# Split header on tab or comma (modify as needed)
IFS=$'\t' read -r -a cols <<< "$header"
declare -A col_indices

for i in "${!cols[@]}"; do
    colname=${cols[$i]}
    # Remove quotes/backticks **and spaces** if present
    colname=$(echo "$colname" | sed 's/^[`"'\'' ]*//;s/[`"'\'' ]*$//')
    #echo "Parsed column name: '$colname'"
    col_indices[$colname]=$((i+1))
done
# see them for debugging
#declare -p col_indices

get_col() {
    local name="$1"
    if [[ "$name" != "" && "$name" != "NA" ]]; then
        if [[ -v col_indices[$name] ]]; then
            echo "${col_indices[$name]}"
        else
            echo "Warning: column '$name' not found in header" >&2
            echo ""
        fi
    else
        echo ""
    fi
}

snp_col_ind=$(get_col "$snp_name")
pos_col_ind=$(get_col "$pos_name")
chrom_col_ind=$(get_col "$chrom_name")
A1_col_ind=$(get_col "$A1_name")
A2_col_ind=$(get_col "$A2_name")
beta_hat_col_ind=$(get_col "$beta_hat_name")
se_col_ind=$(get_col "$se_name")
p_col_ind=$(get_col "$p_value_name")
af_col_ind=$(get_col "$af_name")
ss_col_ind=$(get_col "$sample_size_name")

echo " - broke up gwas file header"

# Step 2: Filter rows by chrom, select columns
if [[ "$file" == *.gz ]]; then
    cmd="gzip -cd \"$file\""
else
    cmd="cat \"$file\""
fi

echo " - obtained whole gwas file"

# Step 3: AWK filtering and formatting
# Write header to output
echo -e "chrom\tpos\tsnp\tA1\tA2\tbeta_hat\tse\tZ\tp_value\tsample_size\tallele_freq" > "$output"

# Main process: decompress and apply AWK filter/formatter
eval "$cmd" | awk \
-v chrom_col="$chrom_col_ind" \
-v chrom="$chrom" \
-v af_col="$af_col_ind" \
-v af_thresh="$af_thresh" \
-v beta_hat_col="$beta_hat_col_ind" \
-v effect_is_or="$effect_is_or" \
-v se_col="$se_col_ind" \
-v pos_col="$pos_col_ind" \
-v snp_col="$snp_col_ind" \
-v A1_col="$A1_col_ind" \
-v A2_col="$A2_col_ind" \
-v ss_col="$ss_col_ind" \
-v output="$output" '
BEGIN {
    OFS="\t";
}
NR==1 { next } # Skip header
{
    # Filter on chromosome
    if ($chrom_col != chrom) next;

    # AF filtering
    af_ok = 1;
    if (af_col != "" && af_col != "NA") {
        af = $af_col;
        if (af == "" || af == "NA") af_ok = 0;
        else if (af <= af_thresh || af >= (1 - af_thresh)) af_ok = 0;
    }
    if (!af_ok) next;

    # Beta adjustment for effect size (log-transform if odds ratio)
    beta_val = $beta_hat_col;
    if (effect_is_or == "TRUE") {
        beta_val = log(beta_val);
    }

    # Compute se value safely
    se_val = ($se_col != "" && $se_col != "NA") ? $se_col : "NA";

    # Compute Z = beta/se if both available
    Z = (se_val != "NA" && se_val != "" && beta_val != "NA" && beta_val != "") ? beta_val / se_val : "NA";

    # Compute p-value using normal_cdf function ONLY if Z is valid
    if (Z != "NA" && Z != "") {
        absz = Z >= 0 ? Z : -Z;
        pvalue = 2 * (1 - normal_cdf(absz));
    } else {
        pvalue = "NA";
    }

    # Output in required order
    print $chrom_col, $pos_col, $snp_col, $A1_col, $A2_col, beta_val, se_val, Z, pvalue, $ss_col, $af_col >> output;
}
# Abramowitz & Stegun, 7.1.26, Normal CDF approximation
function normal_cdf(x,   a1,a2,a3,a4,a5,p,t,erf) {
    a1 = 0.254829592; a2 = -0.284496736; a3 = 1.421413741;
    a4 = -1.453152027; a5 = 1.061405429; p = 0.3275911;
    t = 1 / (1 + p * x / sqrt(2));
    erf = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(- (x * x) / 2 );
    return 0.5 * (1 + erf);
}
'

echo " - calculated:  af filtering, beta OR adjustment, Z, p-value"

echo " - formatted output written to $output"
